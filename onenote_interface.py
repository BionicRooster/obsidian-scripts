"""
onenote_interface.py

Connects to a running OneNote 2021 desktop instance via the Windows COM
API and reads the currently focused page, returning its raw XML content
and a metadata dictionary.

Dependencies:
    pip install pywin32

Usage:
    from onenote_interface import OneNoteInterface
    oni = OneNoteInterface()
    content_xml, metadata = oni.get_current_page()
"""

import logging
import xml.etree.ElementTree as ET
from datetime import datetime, timezone

import comtypes.client   # vtable-based COM; needed because OneNote's IApplication
                         # is a custom (non-dispatch) interface — pywin32's
                         # IDispatch::Invoke returns TYPE_E_LIBNOTREGISTERED for it
import win32gui          # provided by pywin32; used to read window titles

# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

# XML namespace used by OneNote 2013 and later (including 2016, 2019, 2021).
# All elements in hierarchy and page-content XML live in this namespace.
ONE_NS = "http://schemas.microsoft.com/office/onenote/2013/onenote"

# HierarchyScope enum values (from the OneNote COM type library).
# HS_PAGES fetches every level: Notebooks → Sections → Pages.
HS_PAGES = 4

# PageInfo flags used with GetPageContent.
# PI_ALL (7) requests text, binary data (images), selection state, and
# file-type information so that embedded images arrive as base-64 data.
PI_ALL = 7

# ---------------------------------------------------------------------------
# Module-level logger
# ---------------------------------------------------------------------------
log = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Helper: build a Clark-notation XML tag for the OneNote namespace
# ---------------------------------------------------------------------------
def _onetag(local: str) -> str:
    """Return '{namespace}local' format for use with ElementTree."""
    return f"{{{ONE_NS}}}{local}"


# ---------------------------------------------------------------------------
# Main class
# ---------------------------------------------------------------------------
class OneNoteInterface:
    """
    Thin wrapper around the OneNote COM API.

    Responsibilities:
      - Connect to the already-running OneNote 2021 process via COM.
      - Identify the currently focused page by reading the window title.
      - Walk the notebook hierarchy XML to locate that page's element.
      - Extract page metadata (title, dates, notebook, section, deep link).
      - Retrieve the full page content XML including embedded binary images.

    Public API:
        oni = OneNoteInterface()
        content_xml, metadata = oni.get_current_page()
    """

    def __init__(self):
        """Connect to OneNote on instantiation."""
        # _app: the live COM Application object; all API calls go through it
        self._app = None
        self._connect()

    # -----------------------------------------------------------------------
    # Connection
    # -----------------------------------------------------------------------

    def _connect(self):
        """
        Attach to the already-running OneNote process using COM.

        GetActiveObject attaches to an existing COM server instead of
        launching a new one, which is what we need here.

        Raises RuntimeError if OneNote is not currently running.
        """
        try:
            # OneNote's IApplication methods are NOT accessible via late-binding
            # (GetIDsOfNames doesn't expose them), so we must use early-bound
            # wrappers generated by makepy.  EnsureDispatch() fails because
            # GetTypeInfo() on the live OneNote COM object raises an error.
            # Instead, load the pre-generated module by type library GUID and
            # instantiate Application() directly — OneNote is a singleton server
            # so CoCreateInstance attaches to the already-running instance.
            # OneNote's IApplication is a vtable-only custom COM interface.
            # pywin32's IDispatch::Invoke returns TYPE_E_LIBNOTREGISTERED for it.
            # comtypes generates vtable-based wrappers from the type library and
            # calls methods directly through the vtable — no IDispatch needed.
            # GetModule generates (or reuses) Python wrappers from the type lib.
            # CreateObject attaches to the running OneNote singleton.
            onenote_typelib_guid = "{0EA692EE-BB50-4E3C-AEF0-356D91732725}"
            onenote_lib = comtypes.client.GetModule(
                (onenote_typelib_guid, 1, 1, 0)
            )
            self._app = comtypes.client.CreateObject(
                "OneNote.Application",
                interface=onenote_lib.IApplication,
            )
            log.info("Connected to OneNote via COM.")
        except Exception as exc:
            raise RuntimeError(
                "Cannot connect to OneNote.\n"
                "Please make sure OneNote 2021 is open and try again."
            ) from exc

    # -----------------------------------------------------------------------
    # Current page detection via window title
    # -----------------------------------------------------------------------

    def _read_onenote_window_title(self) -> str | None:
        """
        Enumerate all visible top-level windows and return the page title
        extracted from the OneNote application window title.

        OneNote 2021 window title format:
            "Page Name - Section Name - Notebook Name - OneNote"

        When no page is open the title is simply "OneNote".

        Returns the page name string, or None if it cannot be determined.
        """
        # candidates: list of window title strings that look like OneNote
        candidates: list[str] = []

        def _callback(hwnd, _ctx):
            """Called by EnumWindows for every top-level window handle."""
            if win32gui.IsWindowVisible(hwnd):
                title = win32gui.GetWindowText(hwnd)
                # The main OneNote window always ends with " - OneNote"
                # or is exactly "OneNote" when nothing is loaded.
                if " - OneNote" in title:
                    candidates.append(title)

        win32gui.EnumWindows(_callback, None)

        for title in candidates:
            # Split on " - "; the first token is the page name
            parts = [p.strip() for p in title.split(" - ")]
            # Safety check: last part must be "OneNote", and we need ≥2 parts
            if len(parts) >= 2 and parts[-1] == "OneNote":
                page_title = parts[0]   # page name is always the first token
                log.info("Detected page title from window: %r", page_title)
                return page_title

        return None   # could not find the title

    # -----------------------------------------------------------------------
    # Hierarchy walking
    # -----------------------------------------------------------------------

    def _get_hierarchy(self) -> ET.Element:
        """
        Fetch the full notebook hierarchy from OneNote as an XML tree.

        GetHierarchy("", HS_PAGES, "") asks for all notebooks, all sections,
        and all pages starting from the root ("").

        Returns an ElementTree root element for the hierarchy XML.
        """
        # hierarchy_xml: raw XML string containing all notebooks/sections/pages
        # pbstrHierarchyXmlOut is an [out] parameter — omit it; the method
        # returns it as its Python return value when using early-bound stubs.
        hierarchy_xml: str = self._app.GetHierarchy("", HS_PAGES)
        return ET.fromstring(hierarchy_xml)

    def _find_page_element(
        self,
        hierarchy_root: ET.Element,
        page_title: str,
    ) -> tuple[str, ET.Element]:
        """
        Search the hierarchy tree for a <one:Page> element whose 'name'
        attribute matches *page_title*.

        Tries an exact match first, then a case-insensitive match as a
        fallback (useful if the window title casing differs slightly).

        Returns (page_id, page_element).
        Raises RuntimeError if no matching page is found.
        """
        page_tag = _onetag("Page")          # Clark-notation tag to find

        # --- Exact match ---
        for page_el in hierarchy_root.iter(page_tag):
            if page_el.get("name", "") == page_title:
                page_id = page_el.get("ID", "")
                log.info("Found page (exact match), ID=%s", page_id)
                return page_id, page_el

        # --- Case-insensitive fallback ---
        title_lower = page_title.lower()
        for page_el in hierarchy_root.iter(page_tag):
            if page_el.get("name", "").lower() == title_lower:
                page_id = page_el.get("ID", "")
                log.info("Found page (case-insensitive), ID=%s", page_id)
                return page_id, page_el

        # --- Prefix (startswith) fallback ---
        # OneNote truncates long page titles in the window title bar.
        # Match any page whose name starts with the (truncated) title string.
        for page_el in hierarchy_root.iter(page_tag):
            name = page_el.get("name", "")
            if name.lower().startswith(title_lower):
                page_id = page_el.get("ID", "")
                log.info("Found page (prefix match '%s'), ID=%s", name, page_id)
                return page_id, page_el

        raise RuntimeError(
            f"Page '{page_title}' was not found in any open notebook.\n"
            f"Make sure the notebook containing this page is synced and open."
        )

    # -----------------------------------------------------------------------
    # Metadata extraction
    # -----------------------------------------------------------------------

    def _extract_metadata(
        self,
        page_el: ET.Element,
        hierarchy_root: ET.Element,
    ) -> dict:
        """
        Build a metadata dictionary from the page's hierarchy element.

        Also walks the hierarchy tree upward to find the parent Section
        and Notebook names, and requests a OneNote deep-link URL for use
        as the 'source' field in the Obsidian frontmatter.

        Returns a dict with keys:
            page_id, title, created, modified, notebook, section, onenote_link
        """
        # page_id: the GUID that uniquely identifies this page in OneNote
        page_id = page_el.get("ID", "")

        # ---- Parse ISO-8601 timestamps from the hierarchy element ----

        def _fmt_date(raw: str) -> str:
            """Convert '2024-01-15T09:30:00.000Z' → '2024-01-15'."""
            if not raw:
                return ""
            try:
                dt = datetime.fromisoformat(raw.replace("Z", "+00:00"))
                return dt.strftime("%Y-%m-%d")
            except ValueError:
                # If parsing fails, take the first 10 characters (YYYY-MM-DD)
                return raw[:10]

        # created: page creation date (dateTime attribute)
        created = _fmt_date(page_el.get("dateTime", ""))
        # modified: last edit date (lastModifiedTime attribute)
        modified = _fmt_date(page_el.get("lastModifiedTime", ""))

        # ---- Find parent Section and Notebook ----
        # Walk every Notebook → Section → Page path in the hierarchy
        nb_tag  = _onetag("Notebook")
        sec_tag = _onetag("Section")
        pg_tag  = _onetag("Page")

        notebook_name = ""   # name of the notebook that owns this page
        section_name  = ""   # name of the section that owns this page

        for notebook_el in hierarchy_root.iter(nb_tag):
            for section_el in notebook_el.iter(sec_tag):
                for child_page_el in section_el.findall(pg_tag):
                    if child_page_el.get("ID") == page_id:
                        notebook_name = notebook_el.get("name", "")
                        section_name  = section_el.get("name", "")

        # ---- OneNote deep link ----
        # GetHyperlinkToObject returns an "onenote://" URI that opens this
        # specific page when clicked in Windows Explorer / a browser.
        onenote_link = ""
        try:
            # Second arg "" means link to the page itself (not a specific object)
            onenote_link = self._app.GetHyperlinkToObject(page_id, "")
        except Exception as exc:
            log.warning("Could not get OneNote deep link: %s", exc)

        return {
            "page_id":      page_id,
            "title":        page_el.get("name", "Untitled"),
            "created":      created,
            "modified":     modified,
            "notebook":     notebook_name,
            "section":      section_name,
            "onenote_link": onenote_link,
        }

    # -----------------------------------------------------------------------
    # Page content retrieval
    # -----------------------------------------------------------------------

    def _fetch_page_content(self, page_id: str) -> str:
        """
        Call GetPageContent with PI_ALL to retrieve the full page XML,
        including base-64-encoded binary data for every embedded image.

        page_id: the GUID string of the target page
        Returns the raw XML string for the page content.
        """
        # PI_ALL = 7: requests text, binary image data, selection state,
        # and file-type information in a single call.
        # comtypes removes [out] parameters from the call signature and returns
        # them as the function's return value.  Effective signature:
        #   GetPageContent(bstrPageID, pageInfoToExport=0, xsSchema=2) -> str
        # PI_ALL is passed positionally as pageInfoToExport.
        content_xml: str = self._app.GetPageContent(page_id, PI_ALL)
        log.info(
            "Retrieved page content XML (%d chars) for page ID %s.",
            len(content_xml), page_id
        )
        return content_xml

    # -----------------------------------------------------------------------
    # Public entry point
    # -----------------------------------------------------------------------

    def get_current_page(self) -> tuple[str, dict]:
        """
        Identify the currently focused OneNote page and return its
        content and metadata.

        Workflow:
          1. Read the active page title from the OneNote window title bar.
          2. Fetch the full notebook hierarchy.
          3. Locate the matching page element in the hierarchy.
          4. Extract metadata (dates, notebook, section, deep link).
          5. Fetch the page content XML with embedded binary images.

        Returns:
            (content_xml, metadata)
            content_xml  — raw OneNote page XML string
            metadata     — dict with keys: title, created, modified,
                           notebook, section, page_id, onenote_link
        """
        # Step 1: get current page ID from the OneNote Windows collection.
        # app.Windows[1].CurrentPageId is always exact — no truncation issues
        # unlike reading the window title bar.
        try:
            windows    = self._app.Windows     # IOneNoteWindows collection
            window     = windows[0]            # first (active) window, 0-indexed in comtypes
            page_id_direct = window.CurrentPageId
            log.info("Got CurrentPageId from Windows API: %s", page_id_direct)
        except Exception as exc:
            log.warning("Windows API CurrentPageId failed (%s), will use title matching", exc)
            page_id_direct = None

        # Step 2: full hierarchy XML → ElementTree root
        log.info("Fetching notebook hierarchy...")
        hierarchy_root = self._get_hierarchy()

        # Step 3a: if we have the direct page ID, look it up in the hierarchy
        if page_id_direct:
            page_tag = _onetag("Page")
            page_el  = None
            for el in hierarchy_root.iter(page_tag):
                if el.get("ID", "") == page_id_direct:
                    page_el  = el
                    page_id  = page_id_direct
                    log.info("Found page by CurrentPageId, ID=%s", page_id)
                    break
            if page_el is None:
                # ID not in hierarchy — fall back to title matching below
                page_id_direct = None

        # Step 3b: fall back to window-title matching when direct ID unavailable
        if not page_id_direct:
            page_title = self._read_onenote_window_title()
            if not page_title:
                raise RuntimeError(
                    "No focused OneNote page was detected.\n"
                    "Click on a page in OneNote, then run the exporter."
                )
            page_id, page_el = self._find_page_element(hierarchy_root, page_title)

        # Step 4: build the metadata dict
        metadata = self._extract_metadata(page_el, hierarchy_root)

        # Step 5: fetch page content with binary images
        content_xml = self._fetch_page_content(page_id)

        return content_xml, metadata
